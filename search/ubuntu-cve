#!/usr/bin/env python3
#
# Given a CVE ID, queries the ubuntu vulnerability database
# Outputs the status of the vulnerability.
#
# Output is a table of quadruplets:
# cve,package,release,status,note
# where status is one of "needed", "released", "ignored", "needs_triage", and note is the patched package version, if any
#
# Optionally, provide --package and/or --release to filter results

import sys
import requests
import argparse
from bs4 import BeautifulSoup

def paint(status):
    from termcolor import colored


    mapping = {
        'needed': 'red',
        'needs_triage': 'magenta',
        'not_vulnerable': 'green',
        'does_not_exist': 'green',
        'released': 'cyan',
        'ignored':'red',

    }

    c = None
    if status in mapping:
        return colored(status, mapping[status])

    # No color
    return status

def filter_result(conf, entry):
    if conf.package is not None:
        return entry["package"] == conf.package
    if conf.release is not None:
        return entry["release"] == conf.release
    return True

def strip_parens(text):
    text = text.strip()
    if len(text) < 2: return text

    if text[0] == "(" and text[-1] == ")":
        return text[1:-1]
    return text

def get_cve(cve_id):
    res = requests.get(f"https://ubuntu.com/security/{cve_id}")

    if res.status_code != 200:
        return None

    doc = res.text

    soup = BeautifulSoup(doc, "html.parser")

    table = soup.find(class_="cve-table")

    results = []

    this_package = None
    for table_row in table.findAll("tr"):
        # Every now and then, a new spanning first cell tells us which package is concerned
        row_cells = table_row.findAll(lambda e: e.name == "td")
        if row_cells == []: continue

        #print(row_cells)

        # Each row is either package,release,status or just release,status
        assert(len(row_cells) in [2,3])

        if row_cells[0].has_attr("rowspan"):
            assert(len(row_cells) == 3)
            this_package = next(row_cells[0].a.strings)
            release_cell = row_cells[1]
            status_cell = row_cells[2]
        else:
            assert(len(row_cells) == 2)
            release_cell = row_cells[0]
            status_cell = row_cells[1]

        release = release_cell.string.strip()
        status_text = "".join(status_cell.strings).strip()

        status = status_text
        note = None

        if "(" in status_text:
            status = status_text.split("(")[0]
            note = status_text[len(status):]
            note = strip_parens(note)

        status = status.strip().lower().replace(" ", "_")

        ##if status in ["not_vulnerable", "released", "does_not_exist"]:
        #    #version_div = status_cell.find("div")
        #    #print(status_cell)
        #    #if version_div is not None:
        #        text = version_div.next_sibling.string
        #        note = strip_parens(text)

        entry = { "cve":cve_id, "package":this_package, "release":release, "status": status, "note":note }
        results.append(entry)

    return results

def main():
    parser = argparse.ArgumentParser(description="Query ubuntu CVE database")

    parser.add_argument("cve", type=str, nargs="+", help="CVE ID to search for, on the form CVE-2019-17041")
    parser.add_argument("-c", "--color", action="store_true", help="Color-code status types")
    parser.add_argument("-r", "--release", type=str, default=None, help="Ubuntu release codename to show. Default: All")
    parser.add_argument("-p", "--package", type=str, default=None, help="Specific package name (exact) to show. Default: All")
    parser.add_argument("-f", "--format", type=str, default="csv", help="Output format (json,csv). Default: csv")

    conf = parser.parse_args()

    entries = []

    for cve in conf.cve:
        entries += get_cve(cve)
        if entries is None:
            sys.stderr.write(f"No matches for {cve}\n")

    # Remove anything that doesn't match the user's filter
    entries = [ e for e in entries if filter_result(conf, e) ]

    if conf.format == "json":
        print(json.dumps(entries))

    elif conf.format == "csv":
        for e in entries:
            status = e['status']
            if (conf.color): status = paint(status)
            print(f"{e['cve']},{e['package']},{e['release']},{status},{e['note']}")


if __name__ == "__main__":
    sys.exit(main())
