#!/bin/bash
# Run as root
# Installs system-wide packages, so be nice.

DO_FS=0

function die {
  echo $*
  exit 1
}

DEST="${1}"

SCRIPT="${BASH_SOURCE}"
RECON_ROOT=$(cd `dirname "${SCRIPT}"` && pwd)
source "${RECON_ROOT}/_setup.env"

ROOTDIRS=$(ls / | egrep -v '^proc|^sys')

[ -z "$DEST" ] && die "$0 <dest-dir>"

[ -e "$DEST" -a ! -d "${DEST}" ] && die "${DEST} already exists."


mkdir -p $DEST || die "Unable to create ${DEST}"
cd $DEST || die "Unable to enter ${DEST}"

which aa-unconfined || package_install apparmor-utils
echo "AppArmor..."
aa-unconfined > apparmor_unconfined.txt



# This is from the clean tests
if [ -f packages_running_libs.txt ]; then
  # Corelate the running packages list with the known vulns list
  cat packages_vuln.txt packages_running_libs.txt | sort | uniq --repeated > packages_running_vuln.txt
fi

if [ -x "${CHECKSEC}" ]; then
  which readelf || package_install binutils
  echo "Checksec on running binaries..."
  readlink /proc/*/exe |
    while read BIN; do
      ${CHECKSEC} --output=json --file="${BIN}"
      echo -e "\n"
    done > checksec_running.txt

  echo "Checksec on setuid/setgid binaries"
  find / -type f \( -perm -4000 -o -perm -2000 \) 2>/dev/null |
    while read BIN; do
      ${CHECKSEC} --output=json --file="${BIN}"
      echo -e "\n"
    done > checksec_setuid.txt

  echo "Checksec on kernel"
  ${CHECKSEC} --kernel > checksec_kernel.txt
fi

# Gives a good idea of what we ended up installing
package_list > packages_post_recon.txt
cat packages.txt packages_post_recon.txt | sort | uniq --unique >> packages_installed.txt

# Run distro-specific tests
distro_specific_intrusive "${DEST}"

echo "Done."

