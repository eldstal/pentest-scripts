#!/usr/bin/env python3
#
# Add frida's .so file as a dependency to another .so file
# This allows an embedded frida gadget to be autoloaded
# on app startup.
#
# Help:
#   https://www.pentestpartners.com/security-blog/how-to-install-frida-into-an-android-application/
#
#
# 1. Extract a native so file from the apk
#    mkdir -p lib/arm64-v8a/
#    unzip -j app.apk "lib/arm64-v8a/native-lib.so" -d "lib/arm64-v8a/native-lib.so"
# 2. Add frida's gadget so to the same directory as the native so
# 3. Invoke this script as
#    frida_embed_so.py <frida-gadget.so> <native-lib.so>
# 4. Repack and sign the apk
#    aapt remove -v app.apk lib/arm64-v8a/native-lib.so
#    aapt add -v app.apk lib/arm64-v8a/native-lib.so
#    aapt add -v app.apk lib/arm64-v8a/frida-gadget.so
#    java -jar uber-apk-signer-1.1.0.jar -a app.apk
#

import lief
import argparse
import os
import sys


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("frida_gadget_so", type=str, help="Path to frida gadget .so file. Place it in the same directory as the app_lib_so file.")
    parser.add_argument("app_lib_so", type=str, help="Path to existing native library, already present in the app.")

    conf = parser.parse_args()


    if not os.path.exists(conf.app_lib_so):
        print(f"Invalid path {conf.app_lib_so} to application library. Provide a path to an .so file which already exists, in an unpacked apk/lib/<architecture>/ directory.")
        return 1


    frida_name = os.path.basename(conf.frida_gadget_so)
    frida_path = os.path.join(os.path.dirname(conf.app_lib_so), frida_name)

    if not os.path.exists(frida_path):
        print(f"WARNING: The frida gadget does not exist in the same directory as the app_lib_so. Make sure that {frida_name} is available at {frida_path} before repacking the APK.")

    libnative = lief.parse(conf.app_lib_so)
    libnative.add_library(frida_name)
    print(libnative.libraries)
    libnative.write(conf.app_lib_so)

    return 0


if __name__ == "__main__":
    sys.exit(main())

